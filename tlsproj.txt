Project 1 Write-Up:

1) An attacker could potentially modify the type field value to be 0 for any or every packet sent between the client and server, tricking them both into believing there is an error, which will abort the connection between the two, resulting in a DoS attack.

2) “Random” numbers are seeded using the current system time (which is generally just the number of seconds or milliseconds that have elapsed since Jan 1, 1970) so if an attacker knows this method and knows within a reasonable time frame when the premaster secret was generated, they could potentially generate the premaster secret on their own with just a few (on the order of thousands) guesses and break encryption with a MITM attack as follows:

- The attacker observes when the client sends the server the encrypted premaster secret and seeds the random function with the current time (minus 1 second, for example to accommodate for the latency between generating and sending the premaster secret).
- The attacker generates the master secret by concatenating his premaster secret with the public random variables in the hello messages (assume they were already observed), calculates the SHA256 hash of it, and now has the master key!
- Because the remainder of message exchange relies on symmetric encryption/decryption, the attacker can now observe and send any message to either the client or server!!

3) In the current implementation of our TLS handshake, an attacker could potentially modify the client hello message packet and set the cipher suite constant to a weaker one (such as one that looks like TLS_RSA_WITH_DES_64_MD5 thereby ‘downgrading’ the suite to an older one), then if the server agrees to use this cihper suite, and because we know this is crackable, the attacker could now potentially break security on the handshake.  One security measure that could mitigate this attack would be to encrypt the cipher suite field with the server’s public key, that way if an attacker attempts to modify this encrypted value, the modification will be detected once the server tries to decrypt and recieves garbage that does not correspond to a known cipher suite. Assuming the field is not modified, the server would then respond with the same cipher suite encrypted under the client’s public key, which the client would then decrypt with their private key and check that it matches what they initially suggested as the cipher suite.